<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Diff Bio</title>
  <meta name="description" content="Robotics, Software, Science Development" />

  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="wrap">
    <header class="masthead">
      <div class="brand">
        <p class="eyebrow">Diff Bio</p>
        <h1>Development Blog</h1>
        <p>Follow along with developmental updates on Robotics, Software, and Science.</p>
      </div>

      <nav aria-label="Site links">
        <a class="post-toggle" href="https://diff.bio/" target="_blank" rel="noopener">
          Learn More - Contact Us
        </a>
      </nav>
    </header>

    <div class="content-area">
      <div class="pinned-area">
      <div class="section-head">
        <div>
          <h2>Highlighted Posts</h2>
        </div>
      </div>
      <div class="pinned-grid">
        <article class="post pinned-card" data-post="post-protein-dojo"></article>
        <article class="post pinned-card" data-post="post-speed"></article>
        <article class="post pinned-card" data-post="post-lab-sim"></article>
      </div>
    </div>

    <div class="layout">
      <main class="feed" id="feed">
        <article class="post timeline-card" id="post-lab-sim" data-tags="lab-automation" data-date="Jan 15, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 15, 2026</span>
              <span class="tag">Lab Automation</span>
            </div>
          </div>
          <h3 class="post-title">Lab Simulation</h3>

          <p>We built Maestro to de-risk lab automation orchestration before we touch hardware.</p>
          <p>
            The goal is simple: run workflows repeatedly, see where timing and coordination break, and fix that loop before it becomes a hardware problem.
          </p>
          <p>
            At the core is a deterministic simulation engine that advances in fixed 100ms ticks.
            Nodes (robots, stations, instruments) are small state machines that emit telemetry events as they execute commands.
            Because time advances in discrete ticks, we can reproduce “exactly what happened” from the same initial state and inputs — which is ideal for performance questions and corner cases.
          </p>
          <p>
            Control is event-driven.
            The orchestrator talks to the simulation over gRPC, issues commands, and waits on telemetry (arrived, plate picked, command rejected) rather than polling or sleeping.
            In parallel, the browser UI connects to two WebSocket streams: one for raw telemetry and one for orchestrator state.
            That separation is intentional: it keeps the UI useful whether the backend is a simulation or real hardware.
          </p>
          <p>
            We also inject faults on purpose to test recovery behavior early, while it’s cheap to fix.
            The same control surface can later drive real systems, so this isn’t throwaway code.
          </p>
          <p>Next up is expanding scenario coverage and tightening runtime metrics so we can compare changes run-to-run.</p>

          <figure>
            <img class="media-img" src="content/sim_screenshot_1.png" alt="Operation Running" />
          </figure>
          <figure>
            <img class="media-img" src="content/faulted.png" alt="Faulted" />
          </figure>
          <figure>
            <img class="media-img" src="content/metrics.png" alt="Metrics" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-protein-dojo" data-tags="robotics" data-date="Jan 15, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 15, 2026</span>
              <span class="tag">Protein Dojo</span>
            </div>
          </div>
          <h3 class="post-title">Protein Dojo</h3>
          <a class="pill-link" href="https://www.proteindojo.com/" target="_blank" rel="noopener">proteindojo.com</a>

          <p>Protein Dojo makes protein design feel hands-on instead of “read papers and hope.”</p>
          <p>
            For small teams iterating on binders, the difference is loop speed: get to a concrete design decision quickly, with enough feedback to learn what actually changed.
          </p>
          <p>
            Under the hood it’s grounded in real structures.
            You can explore an actual complex (e.g. SARS‑CoV‑2 Spike RBD bound to human ACE2) pulled from the PDB, then design against a specific interface.
          </p>
          <p>
            The workflow is intentionally structured: Explore → Design → Evaluate → Submit.
            That’s where the “cool” becomes useful — you can move between 3D geometry and residue-level sequence changes without losing context.
          </p>
          <p>
            The evaluation loop is the teacher.
            Make a change, re-evaluate, and see why it helped or hurt: clashes, polarity, surface complementarity, and whether the design still looks physically plausible.
          </p>
          <p>Next up is tightening the evaluation signal so iteration feels even more like engineering and less like guesswork.</p>

          <figure>
            <img class="media-img" src="content/protein_dojo.png" alt="Protein Dojo screenshot" />
          </figure>
          <figure>
            <img class="media-img" src="content/dojo2.png" alt="Protein Dojo screenshot" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-rethinking" data-tags="robotics" data-date="Jan 5, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 5, 2026</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Turning A Demo Into Something Reliable</h3>

          <p>We’re turning a working demo into a system that’s predictable under stress.</p>
          <p>
            Reliability is the goal: repeatable behavior, clearer failure modes, and a safety path that doesn’t depend on “everything else behaving.”
          </p>
          <p>
            The current loop runs on a small Linux SBC because it’s convenient for iteration.
            Longer-term we’ll likely split timing-critical motor control onto a dedicated controller, and keep Linux focused on the UI, logging, and coordination.
          </p>
          <p>
            The architecture we’re converging on is three layers:
            hardware I/O and timing (step pulses, servo PWM, limit inputs),
            motion planning (ramps/segments that respect the mechanics),
            and orchestration (station state machine + traceable logs of what happened and why).
          </p>
          <p>
            The key rule is non-blocking control.
            Everything advances on a monotonic tick with explicit state transitions, so adding sensors later becomes “handle new evidence” rather than “rewrite the loop.”
          </p>
          <p>Next up is closing the feedback gaps: station ID, lift position feedback, and a hard stop path that’s independent of application logic.</p>

          <figure>
            <img class="media-img" src="content/robot_v1p1_schematic.png" alt="control schematic draft" />
          </figure>
        </article>

        <article class="post timeline-card pinned" id="post-demo-pick" data-tags="robotics" data-date="Jan 3, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 3, 2026</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">A First End To End Demo</h3>
          <p>The cart picks up a plate, rides the rail, and drops it off — end to end.</p>
          <p>
            This started as a holiday hackathon build.
            The point was to prove we can go from sketch → mechanism → control loop → repeatable motion quickly, then iterate toward robustness.
          </p>
          <p>
            The demo is intentionally simple: two stations, a lift, and one controller loop sequencing the whole operation.
            That simplicity is useful because it makes changes legible — update one variable (mechanism, tuning, software) and you immediately see the effect.
          </p>
          <p>
            Under the hood it’s one SBC running a tight C++ loop: generate step pulses, shape acceleration/deceleration so motion stays smooth, and sequence a station state machine.
            We’re intentionally light on sensors right now so we can pin down the fundamentals before adding complexity.
          </p>
          <p>
            The lift is a servo-driven cam with no latching and no extra feedback, which makes the next steps obvious: plate presence sensing, lift position feedback, and a safety stop path that doesn’t depend on application code.
          </p>
          <p>Next up is adding feedback without losing simplicity: minimal sensors, clear failure modes, and a safer stop-everything path.</p>

          <video class="media-video" controls preload="metadata">
            <source src="content/speed_test_place_h264.mp4" type="video/mp4" />
            Sorry, your browser doesn't support embedded videos.
          </video>
        </article>

        <article class="post timeline-card" id="post-station" data-tags="robotics" data-date="Jan 2, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 2, 2026</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">A Simple Station</h3>

          <p>A station is a small landing pad that makes placement predictable.</p>
          <p>
            The goal is repeatability: when the cart arrives, the plate lands in the same place every time, so the rest of the system can be simpler.
          </p>
          <p>
            Ours is a 3D-printed part with a guiding lip and an overhang that lets the cart position a plate above the station and lower into a known target.
            It’s intentionally modular so we can place multiple stations along the rail without redesigning the system.
          </p>
          <p>
            Later we can add sensing and locking, but this baseline geometry is the foundation for reliable demos and clean integration tests.
          </p>
          <p>Next up is adding just enough sensing to detect “plate present / plate absent” without complicating the mechanism.</p>

          <figure>
            <img class="media-img" src="content/simple_station.png" alt="simple station design" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-cam-lift" data-tags="robotics" data-date="Jan 1, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 1, 2026</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">A Better Lift Mechanism</h3>

          <p>We replaced a scissor lift with a compact servo-driven cam lift.</p>
          <p>
            The goal is controlled motion: less flex, less torque on printed parts, and a lift path that’s smooth enough to keep plates stable.
          </p>
          <p>
            The scissor version looked fine in CAD but flexed too much in the printed assembly and loaded the plastic in the wrong ways.
            The cam lift is stiffer and simpler to tune because the cam profile can shape acceleration/deceleration mechanically, not just in software.
          </p>
          <p>
            It’s also a better base for feedback: adding a position sensor or a hard stop is straightforward compared to debugging a flexy linkage.
          </p>
          <p>Next up is adding lift position feedback so the controller can detect “not where expected” and react safely.</p>

          <figure>
            <img class="media-img" src="content/cam_lift.png" alt="cam lift design" />
            <img class="media-img" src="content/plate_holding.jpg" alt="cam lift design" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-wire-clean" data-tags="robotics" data-date="Dec 27, 2025">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Dec 27, 2025</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Wiring That Survives Real Life</h3>

          <p>We cleaned up wiring so iteration doesn’t come with a reliability tax.</p>
          <p>
            The goal is stable debugging: change one thing, observe the effect, and avoid introducing new failures from loose jumpers and tangled cables.
          </p>
          <p>
            The breadboard era is over.
            We moved to perfboard with headers for 12V motor power, stepper phases, and station reed switches, and routed moving wires so they can’t snag during motion.
          </p>
          <p>
            The bigger lesson is that moving wiring is a design problem.
            Suspending the stepper phase wires above the rail immediately forces the right production questions (tethered cart vs. power-from-rail, where the controller should live) while keeping the demo simple.
          </p>
          <p>Next up is wiring and connectors that support fault isolation and safe shutdown, not just “it runs.”</p>

          <figure>
            <img class="media-img" src="content/rewire.jpg" alt="consolidation of electrical design" />
          </figure>

          <p>Everything now breaks out cleanly, which makes debugging (and reconfiguring) much less painful.</p>
          <figure>
            <img class="media-img" src="content/board_front.jpg" alt="consolidation of electrical design" />
          </figure>
          <figure>
            <img class="media-img" src="content/board_back.jpg" alt="consolidation of electrical design" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-speed" data-tags="robotics software" data-date="Dec 26, 2025">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Dec 26, 2025</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Getting The Rail Moving Fast</h3>

          <p>We pushed rail speed to find the real limits, not the comfortable ones.</p>
          <p>
            The constraint shows up quickly: aggressive acceleration creates torque that can lift the cart off the track, so mechanical design and packaging are the next wins.
          </p>
          <p>
            On the control side we split responsibilities:
            a low-level stepper controller generates the pulse train and handles accel/decel ramps, while a higher-level position controller runs the station/direction state machine.
            That separation keeps timing predictable and makes it clear where to add feedback later.
          </p>
          <p>Next up is tightening the mechanical envelope (torque, clamping, mass distribution) so software can safely ask for more speed.</p>

          <video class="media-video" controls preload="metadata">
            <source src="content/speed_test.mp4" type="video/mp4" />
            Sorry, your browser doesn't support embedded videos.
          </video>
        </article>

        <article class="post timeline-card" id="post-cad" data-tags="robotics" data-date="Dec 21, 2025">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Dec 21, 2025</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Arguing In 3D Before Printing</h3>

          <p>We modeled the whole mechanism in CAD so we could trade time in software for fewer reprints.</p>
          <p>
            The goal is risk reduction: catch interference, bad load paths, and packaging mistakes before the physical pile-up on the bench.
          </p>
          <p>
            The rails and bearing wheels are the only truly fixed parts; almost everything else is printable.
            Building the system as sub-assemblies made it easier to reason about actuator placement, gear rail location, and clearances before we committed to a layout.
          </p>
          <p>
            CAD also surfaced constraints early.
            Servo cable length pushed us to keep the SBC off-cart for initial testing, and the first scissor lift load path made it clear we needed a redesign to reduce torque on printed parts.
          </p>
          <p>Next up is iterating the packaging so the mechanical stack and wiring routes support reliable motion, not just first-time assembly.</p>

          <figure>
            <img class="media-img" src="content/cad1.png" alt="" />
            <img class="media-img" src="content/cad2.png" alt="" />
            <img class="media-img" src="content/cad3.png" alt="" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-sketches" data-tags="robotics" data-date="Dec 18, 2025">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Dec 18, 2025</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">The First Sketches</h3>

          <p>The original idea: move plates like a tiny factory line instead of a fancy robot arm.</p>
          <p>
            The goal was to learn fast: validate the motion system and handoff mechanics before we invest in a more complex automation layout.
          </p>
          <p>
            The plan was straightforward: buy metal rails, suspend them on printed stands, and keep the cart’s top surface dedicated to holding a plate.
            Everything else (controller, actuators, lift) hangs underneath so stations can overhang the track and the cart can deposit/pick up without extra mechanisms at each station.
          </p>
          <p>
            The earliest lift concept was a spooling/scissor setup.
            It got us moving quickly and surfaced the real constraints early: torque, rigidity, and cable management.
          </p>
          <p>Next up is turning the sketches into CAD so we can converge on a printable, assemblable stack.</p>

          <figure>
            <img class="media-img" src="content/sketch1.png" alt="" />
            <img class="media-img" src="content/sketch2.png" alt="" />
          </figure>
        </article>
      </main>
      <aside class="timeline-rail" id="timeline-rail">
        <div class="rail-line"></div>
      </aside>
    </div>
    </div>
    <footer>
      © <span id="year"></span>
    </footer>
  </div>

  <div class="media-modal" id="media-modal" aria-hidden="true">
    <div class="media-modal__backdrop" data-modal-close></div>
    <div class="media-modal__content" role="dialog" aria-modal="true" aria-label="Image preview">
      <img class="media-modal__img" alt="" />
      <button class="media-modal__close" type="button" data-modal-close>Close</button>
    </div>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    const feedPosts = Array.from(document.querySelectorAll(".feed .post"));
    const timelineRail = document.getElementById("timeline-rail");
    const timelineNodes = [];
    let activeGroup = "";

    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const parseDate = (value) => {
      if (!value) return null;
      const parsed = new Date(value);
      if (Number.isNaN(parsed.getTime())) return null;
      return parsed;
    };
    const getPostDateString = (post) => {
      const attr = post.dataset.date?.trim();
      if (attr) return attr;
      const dateEl = post.querySelector(".date");
      return dateEl?.textContent?.trim() || "";
    };
    const monthKeyFromDate = (value) => {
      const parsed = parseDate(value);
      if (!parsed) return "Unknown";
      return `${parsed.getFullYear()}-${String(parsed.getMonth() + 1).padStart(2, "0")}`;
    };
    const monthLabelFromDate = (value) => {
      const parsed = parseDate(value);
      if (!parsed) return "Unknown";
      return `${monthNames[parsed.getMonth()]} ${parsed.getFullYear()}`;
    };
    const getPostMeta = () =>
      feedPosts.map((post, index) => {
        const dateString = getPostDateString(post);
        const parsed = parseDate(dateString);
        return {
          index,
          post,
          parsed,
          timestamp: parsed ? parsed.getTime() : null,
          groupKey: monthKeyFromDate(dateString),
          groupLabel: monthLabelFromDate(dateString),
        };
      });

    const setActiveTimelineGroup = (groupKey) => {
      activeGroup = groupKey;
      timelineNodes.forEach((node) => {
        node.classList.toggle("active", node.dataset.group === groupKey && !node.hidden);
      });
    };

    const scrollToPostIndex = (index) => {
      const target = feedPosts[index];
      if (!target || target.hidden) return;
      target.scrollIntoView({ behavior: "smooth", block: "start" });
    };

    const createTimeline = () => {
      timelineRail.innerHTML = '<div class="rail-line"></div>';
      const todayButton = document.createElement("button");
      todayButton.type = "button";
      todayButton.className = "timeline-today";
      todayButton.textContent = "Today";
      todayButton.addEventListener("click", () => {
        const meta = getPostMeta()
          .filter((item) => !item.post.hidden)
          .sort((a, b) => (b.timestamp ?? -Infinity) - (a.timestamp ?? -Infinity));
        if (meta.length) scrollToPostIndex(meta[0].index);
      });
      timelineRail.appendChild(todayButton);

      const meta = getPostMeta();
      const groups = Array.from(
        meta
          .filter((item) => item.groupKey !== "Unknown")
          .reduce((acc, item) => {
            if (!acc.has(item.groupKey)) {
              acc.set(item.groupKey, {
                key: item.groupKey,
                label: item.groupLabel,
                timestamp: item.timestamp ?? -Infinity,
              });
            }
            return acc;
          }, new Map())
          .values()
      ).sort((a, b) => b.timestamp - a.timestamp);

      groups.forEach((group) => {
        const node = document.createElement("button");
        node.type = "button";
        node.className = "timeline-node";
        node.dataset.group = group.key;
        node.innerHTML = `
          <span class="timeline-dot"></span>
          <span class="timeline-label">${group.label}</span>
        `;
        node.addEventListener("click", () => {
          const groupPosts = meta.filter((item) => item.groupKey === group.key);
          if (!groupPosts.length) return;
          const target = groupPosts.sort((a, b) => (b.timestamp ?? -Infinity) - (a.timestamp ?? -Infinity))[0];
          scrollToPostIndex(target.index);
        });
        timelineRail.appendChild(node);
        timelineNodes.push(node);
      });
    };

    createTimeline();
    if (feedPosts.length) {
      const meta = getPostMeta().sort((a, b) => (b.timestamp ?? -Infinity) - (a.timestamp ?? -Infinity));
      setActiveTimelineGroup(meta[0]?.groupKey || "");
    }

    const updateActiveOnScroll = () => {
      const threshold = window.scrollY + window.innerHeight / 3;
      let current = activeGroup;
      for (let i = 0; i < feedPosts.length; i += 1) {
        const post = feedPosts[i];
        if (post.hidden) continue;
        if (post.offsetTop >= threshold) {
          current = monthKeyFromDate(getPostDateString(post));
          break;
        }
      }
      if (current) setActiveTimelineGroup(current);
    };

    let scrollScheduled = false;
    window.addEventListener("scroll", () => {
      if (scrollScheduled) return;
      scrollScheduled = true;
      requestAnimationFrame(() => {
        updateActiveOnScroll();
        scrollScheduled = false;
      });
    });

    const SUMMARY_MAX_CHARS = 110;

    const truncateAtWord = (text, maxChars) => {
      const clean = text.trim().replace(/\s+/g, " ");
      if (clean.length <= maxChars) return clean;
      const sliced = clean.slice(0, maxChars + 1);
      const lastSpace = sliced.lastIndexOf(" ");
      const cut = (lastSpace > 40 ? sliced.slice(0, lastSpace) : sliced.slice(0, maxChars)).trim();
      return `${cut}...`;
    };

    const getFirstSentence = (text) => {
      const match = text.match(/[^.!?]+[.!?]+/);
      return match ? match[0].trim() : text.trim();
    };

    const getSummaryText = (text) => truncateAtWord(getFirstSentence(text), SUMMARY_MAX_CHARS);

    const populatePinnedPosts = () => {
      const pinnedCards = Array.from(document.querySelectorAll(".pinned-card[data-post]"));
      pinnedCards.forEach((card) => {
        const targetId = card.dataset.post;
        if (!targetId) return;
        const source = document.getElementById(targetId);
        if (!source) return;

        const meta = source.querySelector(".meta");
        const dateText = source.querySelector(".date")?.textContent?.trim() || "";
        const tagText = meta?.querySelector(".tag")?.textContent?.trim() || "";
        const titleText = source.querySelector(".post-title")?.textContent?.trim() || "";
        const firstParagraph = source.querySelector("p");
        const summaryText = firstParagraph ? getSummaryText(firstParagraph.textContent) : "";
        const media = source.querySelector("img, video");

        card.innerHTML = "";

        const metaWrap = document.createElement("div");
        metaWrap.className = "meta";
        if (dateText) {
          const dateSpan = document.createElement("span");
          dateSpan.textContent = dateText;
          metaWrap.appendChild(dateSpan);
        }
        if (tagText) {
          const tagSpan = document.createElement("span");
          tagSpan.className = "tag";
          tagSpan.textContent = tagText;
          metaWrap.appendChild(tagSpan);
        }
        card.appendChild(metaWrap);

        const title = document.createElement("h3");
        title.className = "post-title";
        title.textContent = titleText;
        card.appendChild(title);

        if (summaryText) {
          const summary = document.createElement("p");
          summary.textContent = summaryText;
          card.appendChild(summary);
        }

        if (media) {
          if (media.tagName.toLowerCase() === "video") {
            const video = document.createElement("video");
            video.className = "media-video pinned-media";
            video.autoplay = true;
            video.muted = true;
            video.loop = true;
            video.playsInline = true;
            const sourceEl = media.querySelector("source");
            if (sourceEl?.getAttribute("src")) {
              const src = sourceEl.getAttribute("src");
              const type = sourceEl.getAttribute("type") || "video/mp4";
              const sourceNode = document.createElement("source");
              sourceNode.setAttribute("src", src);
              sourceNode.setAttribute("type", type);
              video.appendChild(sourceNode);
            }
            card.appendChild(video);
          } else {
            const img = document.createElement("img");
            img.className = "media-img pinned-media";
            img.src = media.getAttribute("src") || "";
            img.alt = media.getAttribute("alt") || "";
            card.appendChild(img);
          }
        }

        const link = document.createElement("a");
        link.className = "subtle-link";
        link.href = `#${targetId}`;
        link.textContent = "Jump to full post";
        card.appendChild(link);
      });
    };

    const buildPostSummaries = () => {
      feedPosts.forEach((post) => {
        const firstParagraph = post.querySelector("p");
        if (!firstParagraph) return;

        const summary = document.createElement("p");
        summary.className = "post-summary";
        summary.textContent = getSummaryText(firstParagraph.textContent);
        post.insertBefore(summary, firstParagraph);

        const mediaSummary = document.createElement("div");
        mediaSummary.className = "post-media-summary";
        const mediaItems = Array.from(post.querySelectorAll("img, video"));
        mediaItems.forEach((item) => {
          if (item.closest(".post-media-summary")) return;
          const clone = item.cloneNode(true);
          clone.classList.add("media-thumb");
          if (clone.tagName.toLowerCase() === "video") {
            clone.removeAttribute("controls");
            clone.muted = true;
            clone.loop = true;
            clone.playsInline = true;
            clone.autoplay = true;
            clone.preload = "metadata";
          }
          mediaSummary.appendChild(clone);
        });
        if (mediaSummary.children.length) {
          post.insertBefore(mediaSummary, firstParagraph);
        }

        const body = document.createElement("div");
        body.className = "post-body";
        post.insertBefore(body, firstParagraph);

        let current = body.nextSibling;
        while (current) {
          const next = current.nextSibling;
          body.appendChild(current);
          current = next;
        }

        const toggle = document.createElement("button");
        toggle.type = "button";
        toggle.className = "post-toggle";
        toggle.textContent = "Read More";
        toggle.setAttribute("aria-expanded", "false");
        toggle.addEventListener("click", () => {
          const expanded = post.classList.toggle("expanded");
          toggle.textContent = expanded ? "Read Less" : "Read More";
          toggle.setAttribute("aria-expanded", expanded ? "true" : "false");
        });
        post.appendChild(toggle);
      });
    };

    const modal = document.getElementById("media-modal");
    const modalImage = modal?.querySelector(".media-modal__img");
    const closeModal = () => {
      if (!modal || !modalImage) return;
      modal.classList.remove("is-open");
      modal.setAttribute("aria-hidden", "true");
      modalImage.src = "";
    };
    const openModal = (src, alt) => {
      if (!modal || !modalImage) return;
      modalImage.src = src;
      modalImage.alt = alt || "";
      modal.classList.add("is-open");
      modal.setAttribute("aria-hidden", "false");
    };

    buildPostSummaries();
    populatePinnedPosts();

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      if (target.closest("[data-modal-close]")) {
        closeModal();
        return;
      }
      const image = target.closest("img.media-img, img.media-thumb");
      if (image instanceof HTMLImageElement) {
        openModal(image.src, image.alt);
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") closeModal();
    });
  </script>
</body>
</html>

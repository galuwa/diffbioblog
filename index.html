<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Diff Bio</title>
  <meta name="description" content="Robotics, Software, Science Development" />

  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="wrap">
    <header class="masthead">
      <div class="brand">
        <p class="eyebrow">Diff Bio</p>
        <h1>Development Blog</h1>
        <p>Follow along with developmental updates on Robotics, Software, and Science.</p>
      </div>

    </header>

    <div class="content-area">
      <div class="pinned-area">
      <div class="section-head">
        <div>
          <h2>Highlighted Posts</h2>
        </div>
      </div>
      <div class="pinned-grid">
        <article class="post pinned-card" data-post="post-protein-dojo"></article>
        <article class="post pinned-card" data-post="post-speed"></article>
      </div>
    </div>

    <div class="layout">
      <main class="feed" id="feed">
        <article class="post timeline-card" id="post-lab-sim" data-tags="lab-automation" data-date="Jan 15, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 15, 2026</span>
              <span class="tag">Lab Automation</span>
            </div>
          </div>
          <h3 class="post-title">Prototype Lab Orchestration & Simulation</h3>

          <p>The lab simulation prototype models station flow and timing for rapid automation experiments.</p>
          <p>
            This build focuses on validating our station layout assumptions, queueing behavior, and basic throughput using a lightweight simulation loop.
            The goal is to reduce iteration time before committing to hardware changes by letting us test motion, timing, and control strategies in a repeatable sandbox.
            The Orchestration is designed so that it can coneect directly to a hardware telemetry server and control real hardware with the same interface.
          </p>

          <figure>
            <img class="media-img" src="content/lab_sim.gif" alt="lab simulation prototype loop" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-protein-dojo" data-tags="robotics" data-date="Jan 15, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 5, 2026</span>
              <span class="tag">Protein Dojo</span>
            </div>
          </div>
          <h3 class="post-title">ProteinDojo</h3>
          <a class="pill-link" href="https://www.proteindojo.com/" target="_blank" rel="noopener">> proteindojo.com</a>

          <p>Master the art of protein design</p>
          <p>
            Learn to build proteins with real druggable targets and industry-grade computational tools.
            ProteinDojo started as a side project to make protein design feel more tangible and less mystical. It’s a hands-on playground where people can try real protein design challenges using modern AI tools, without needing a deep computational biology background or a massive lab setup. 
            It shows how we think about tooling, education, and accessibility, and how quickly we can turn complex scientific workflows into something interactive and usable. For users, it’s a fun way to actually do protein design instead of just reading about it.
          </p>

          <figure>
            <img class="media-img" src="content/protein_dojo.png" alt="looking forward" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-rethinking" data-tags="robotics" data-date="Jan 5, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 5, 2026</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Rethinking Robot Design Moving Forward</h3>

          <p>
            Starting to brainstorm improvements to the architecture - NFC station detection, ADC to enable analog hall effect sensors for lift position feedback.
            Using MOSFET AND gates, I can drive the motor enable pin based on an ESTOP, specific motor operation and overall fault detection state. The current
            design drives the TMCs with step/dir GPIO, but moving to UART will give us access to more robust control and advanced features present in the
            register configuration.
          </p>
          <p>
            Using the Pi Zero W gives us a convenient Linux platform with wireless connectivity, but it's not the ideal real-time control computer.
            For preliminary development, I think it's sufficient, and my research indicates we can expect IO latencies on the order of a few milliseconds with
            a well configured system. As our control cycle is constrained to 100Hz, this is sufficient for the time-being. Moving forward, I would like to explore
            more robust real-time platforms, possibly an RTOS or microcontroller-based solution. The Pi could be a Linux interface computer which communicates
            with an STM32 or similar microcontroller over SPI or UART to offload real-time control tasks.
          </p>

          <figure>
            <img class="media-img" src="content/robot_v1p1_schematic.png" alt="looking forward" />
          </figure>
        </article>

        <article class="post timeline-card pinned" id="post-demo-pick" data-tags="robotics" data-date="Jan 3, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 3, 2026</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Demo Pick and Place</h3>
          <p>
            This is a demo of the rail robot performing a pick and place operation. The cart moves along the rail to the first station, lowers the lift mechanism to pick up
            the plate, then moves to the second station and lowers the lift mechanism to deposit the plate. The entire operation is controlled by a single-board computer
            running a real-time C++ control loop. The speed and acceleration of the cart is controlled to ensure smooth movement and prevent dropping the plate and the lift
            mechanism is a simple cam mechanism driven by a servo motor without any additional sensors or latching. This approach can be further improved with the addition
            of sensors to detect plate presence and ensure proper placement.
          </p>

          <video class="media-video" controls preload="metadata">
            <source src="content/speed_test_place.mp4" type="video/mp4" />
            Sorry, your browser doesn't support embedded videos.
          </video>
        </article>

        <article class="post timeline-card" id="post-station" data-tags="robotics" data-date="Jan 2, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 2, 2026</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Simple Station Design</h3>

          <p>
            To facilitate plate placement and pickup, I designed a simple station which can be 3D printed. The station has a lip which extends over the rail, allowing the
            cart to position the plate over the station and then lower the lift mechanism to deposit the plate. The station is designed to be modular, allowing for multiple
            stations to be placed along the rail as needed. This is the simplest possible design for the demo, but in a production system, we would want to incorporate sensors and possibly locking mechanisms to ensure
            proper plate placement and security.
          </p>

          <figure>
            <img class="media-img" src="content/simple_station.png" alt="simple station design" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-cam-lift" data-tags="robotics" data-date="Jan 1, 2026">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Jan 1, 2026</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Cam Lift Redesign</h3>

          <p>
            The scissor lift mechanism I initially designed for lifting the plates was not sufficiently rigid, and introduced too much torque on the plastic parts.
            I redesigned the lift to use a cam mechanism which is driven by a servo motor. This design is much more compact, rigid, and provides a smooth lifting motion.
            The cam profile was designed to provide a gradual acceleration and deceleration of the lift, which minimizes the risk of dropping the plate during movement.
          </p>

          <figure>
            <img class="media-img" src="content/cam_lift.png" alt="cam lift design" />
            <img class="media-img" src="content/plate_holding.jpg" alt="cam lift design" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-wire-clean" data-tags="robotics" data-date="Dec 27, 2025">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Dec 27, 2025</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Wire Clean Up Effort</h3>

          <p>
            Now that the rail robot prototype is consistently up and running, it felt like a good opportunity to clean up the wiring and move away from dupont cables.
            I replicated the breadboard setup on a solderable breadboard and added headers to interface with the 12V motor power, stepper phases, and station reed switches.
            The board should remain fairly extensible, but is much more robust to accidents and cat interactions.
          </p>
          <p>
            One of the more important changes was suspending the stepper motor phase wires above the rail mechanism, which ensures there is no tangling during operation.
            This is ultimately one of the larger considerations for production design when trading a tethered vs. self contained solution which sources power from a rail.
            For this demo, I wanted to keep the design as simple as possible which meant, keeping logical control components off the cart.
          </p>

          <figure>
            <img class="media-img" src="content/rewire.jpg" alt="consolidation of electrical design" />
          </figure>

          <p>
            I exposed headers for all connections to the single board computer, stepper motor, servos, and reed switches. This should make it easier to debug and reconfigure.
          </p>
          <figure>
            <img class="media-img" src="content/board_front.jpg" alt="consolidation of electrical design" />
          </figure>
          <figure>
            <img class="media-img" src="content/board_back.jpg" alt="consolidation of electrical design" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-speed" data-tags="robotics software" data-date="Dec 26, 2025">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Dec 26, 2025</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Rail Robot Speed Testing</h3>

          <p>
            This is the result of preliminary speed testing for the rail system robot. Using the real-time C++ control library I was able to split actuator control
            into two components: StepperControl and PositionControl - the former is responsible for generating a pulse wave to the stepper phases, and handling the
            various phases of acceleration/deceleration; The latter is responsible for high level system control of position and keeping a state machine of station
            passage and direction.
          </p>
          <p>
            This speed is highly dependent on the weight provided by the stepper motors - without additional rail clamping mechanisms, the acceleration must be a gradual
            process, else the laterally offset gear will kick the cart off the track. Ultimately, we would want to center this mechanism or counteract the torque on a
            production design.
          </p>

          <video class="media-video" controls preload="metadata">
            <source src="content/speed_test.mp4" type="video/mp4" />
            Sorry, your browser doesn't support embedded videos.
          </video>
        </article>

        <article class="post timeline-card" id="post-cad" data-tags="robotics" data-date="Dec 21, 2025">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Dec 21, 2025</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">CAD Design and Iteration</h3>

          <p>
            I designed the entire system in CAD before writing software and assembling any hardware. The metal rails and ball bearing wheels were ordered, but all other
            mechanical parts can be 3D printed. I modeled the metal parts and was able to form sub-assemblies in CAD to capture mechanical interactions between the parts.
            I deviated a bit from the initial drawings with respect to the location of the gear rail and position of the actuators. Because the servos arrived with extremely
            long phase cables, I decided to keep the single board computer off the cart for initial testing.
          </p>
          <p> 
            I designed a scissor lift mechanism for lifting the plates, but the existing design introduces too much torque on the plastic parts. This will need to be redesigned
            with another gear system, but I will likely shelve work on that until I can complete motion platform testing, and demonstrate fluid movement.
          </p>

          <figure>
            <img class="media-img" src="content/cad1.png" alt="" />
            <img class="media-img" src="content/cad2.png" alt="" />
            <img class="media-img" src="content/cad3.png" alt="" />
          </figure>
        </article>

        <article class="post timeline-card" id="post-sketches" data-tags="robotics" data-date="Dec 18, 2025">
          <div class="timeline-meta">
            <span class="timeline-dot"></span>
            <div class="meta">
              <span class="date">Dec 18, 2025</span>
              <span class="tag">Rail Robot - Holiday Hackathon</span>
            </div>
          </div>
          <h3 class="post-title">Initial Demo Sketches & Designs</h3>

          <p> 
            I initially sketched out the rough design for the holiday hackathon. I'll buy metal rails and suspend them using PLA, 3D printed stands. The computer,
            actuators, and lifting mechanism should be mounted on the bottom of the cart, leaving the top to hold the plate. The preliminary idea is to use a spooling
            mechanism with a scissor lift to place the plates onto stations which stick out over the track. The cart can lift the plates prior to arrival and then lower
            the lifting mechanism in order to leave the plate at the station. This enabled picking and placing plates without additional external mechanisms at each station
            and is sufficient for the demo.
          </p>

          <figure>
            <img class="media-img" src="content/sketch1.png" alt="" />
            <img class="media-img" src="content/sketch2.png" alt="" />
          </figure>
        </article>
      </main>
      <aside class="timeline-rail" id="timeline-rail">
        <div class="rail-line"></div>
      </aside>
    </div>
    </div>
    <footer>
      © <span id="year"></span>
    </footer>
  </div>

  <div class="media-modal" id="media-modal" aria-hidden="true">
    <div class="media-modal__backdrop" data-modal-close></div>
    <div class="media-modal__content" role="dialog" aria-modal="true" aria-label="Image preview">
      <img class="media-modal__img" alt="" />
      <button class="media-modal__close" type="button" data-modal-close>Close</button>
    </div>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    const feedPosts = Array.from(document.querySelectorAll(".feed .post"));
    const timelineRail = document.getElementById("timeline-rail");
    const timelineNodes = [];
    let activeGroup = "";

    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const parseDate = (value) => {
      if (!value) return null;
      const parsed = new Date(value);
      if (Number.isNaN(parsed.getTime())) return null;
      return parsed;
    };
    const getPostDateString = (post) => {
      const attr = post.dataset.date?.trim();
      if (attr) return attr;
      const dateEl = post.querySelector(".date");
      return dateEl?.textContent?.trim() || "";
    };
    const monthKeyFromDate = (value) => {
      const parsed = parseDate(value);
      if (!parsed) return "Unknown";
      return `${parsed.getFullYear()}-${String(parsed.getMonth() + 1).padStart(2, "0")}`;
    };
    const monthLabelFromDate = (value) => {
      const parsed = parseDate(value);
      if (!parsed) return "Unknown";
      return `${monthNames[parsed.getMonth()]} ${parsed.getFullYear()}`;
    };
    const getPostMeta = () =>
      feedPosts.map((post, index) => {
        const dateString = getPostDateString(post);
        const parsed = parseDate(dateString);
        return {
          index,
          post,
          parsed,
          timestamp: parsed ? parsed.getTime() : null,
          groupKey: monthKeyFromDate(dateString),
          groupLabel: monthLabelFromDate(dateString),
        };
      });

    const setActiveTimelineGroup = (groupKey) => {
      activeGroup = groupKey;
      timelineNodes.forEach((node) => {
        node.classList.toggle("active", node.dataset.group === groupKey && !node.hidden);
      });
    };

    const scrollToPostIndex = (index) => {
      const target = feedPosts[index];
      if (!target || target.hidden) return;
      target.scrollIntoView({ behavior: "smooth", block: "start" });
    };

    const createTimeline = () => {
      timelineRail.innerHTML = '<div class="rail-line"></div>';
      const todayButton = document.createElement("button");
      todayButton.type = "button";
      todayButton.className = "timeline-today";
      todayButton.textContent = "Today";
      todayButton.addEventListener("click", () => {
        const meta = getPostMeta()
          .filter((item) => !item.post.hidden)
          .sort((a, b) => (b.timestamp ?? -Infinity) - (a.timestamp ?? -Infinity));
        if (meta.length) scrollToPostIndex(meta[0].index);
      });
      timelineRail.appendChild(todayButton);

      const meta = getPostMeta();
      const groups = Array.from(
        meta
          .filter((item) => item.groupKey !== "Unknown")
          .reduce((acc, item) => {
            if (!acc.has(item.groupKey)) {
              acc.set(item.groupKey, {
                key: item.groupKey,
                label: item.groupLabel,
                timestamp: item.timestamp ?? -Infinity,
              });
            }
            return acc;
          }, new Map())
          .values()
      ).sort((a, b) => b.timestamp - a.timestamp);

      groups.forEach((group) => {
        const node = document.createElement("button");
        node.type = "button";
        node.className = "timeline-node";
        node.dataset.group = group.key;
        node.innerHTML = `
          <span class="timeline-dot"></span>
          <span class="timeline-label">${group.label}</span>
        `;
        node.addEventListener("click", () => {
          const groupPosts = meta.filter((item) => item.groupKey === group.key);
          if (!groupPosts.length) return;
          const target = groupPosts.sort((a, b) => (b.timestamp ?? -Infinity) - (a.timestamp ?? -Infinity))[0];
          scrollToPostIndex(target.index);
        });
        timelineRail.appendChild(node);
        timelineNodes.push(node);
      });
    };

    createTimeline();
    if (feedPosts.length) {
      const meta = getPostMeta().sort((a, b) => (b.timestamp ?? -Infinity) - (a.timestamp ?? -Infinity));
      setActiveTimelineGroup(meta[0]?.groupKey || "");
    }

    const updateActiveOnScroll = () => {
      const threshold = window.scrollY + window.innerHeight / 3;
      let current = activeGroup;
      for (let i = 0; i < feedPosts.length; i += 1) {
        const post = feedPosts[i];
        if (post.hidden) continue;
        if (post.offsetTop >= threshold) {
          current = monthKeyFromDate(post.dataset.date);
          break;
        }
      }
      if (current) setActiveTimelineGroup(current);
    };

    let scrollScheduled = false;
    window.addEventListener("scroll", () => {
      if (scrollScheduled) return;
      scrollScheduled = true;
      requestAnimationFrame(() => {
        updateActiveOnScroll();
        scrollScheduled = false;
      });
    });

    const getFirstSentence = (text) => {
      const match = text.match(/[^.!?]+[.!?]+/);
      return match ? match[0].trim() : text;
    };

    const populatePinnedPosts = () => {
      const pinnedCards = Array.from(document.querySelectorAll(".pinned-card[data-post]"));
      pinnedCards.forEach((card) => {
        const targetId = card.dataset.post;
        if (!targetId) return;
        const source = document.getElementById(targetId);
        if (!source) return;

        const meta = source.querySelector(".meta");
        const dateText = source.querySelector(".date")?.textContent?.trim() || "";
        const tagText = meta?.querySelector(".tag")?.textContent?.trim() || "";
        const titleText = source.querySelector(".post-title")?.textContent?.trim() || "";
        const firstParagraph = source.querySelector("p");
        const summaryText = firstParagraph ? getFirstSentence(firstParagraph.textContent.trim()) : "";
        const media = source.querySelector("img, video");

        card.innerHTML = "";

        const metaWrap = document.createElement("div");
        metaWrap.className = "meta";
        if (dateText) {
          const dateSpan = document.createElement("span");
          dateSpan.textContent = dateText;
          metaWrap.appendChild(dateSpan);
        }
        if (tagText) {
          const tagSpan = document.createElement("span");
          tagSpan.className = "tag";
          tagSpan.textContent = tagText;
          metaWrap.appendChild(tagSpan);
        }
        card.appendChild(metaWrap);

        const title = document.createElement("h3");
        title.className = "post-title";
        title.textContent = titleText;
        card.appendChild(title);

        if (summaryText) {
          const summary = document.createElement("p");
          summary.textContent = summaryText;
          card.appendChild(summary);
        }

        if (media) {
          if (media.tagName.toLowerCase() === "video") {
            const video = document.createElement("video");
            video.className = "media-video pinned-media";
            video.autoplay = true;
            video.muted = true;
            video.loop = true;
            video.playsInline = true;
            const sourceEl = media.querySelector("source");
            if (sourceEl?.getAttribute("src")) {
              const src = sourceEl.getAttribute("src");
              const type = sourceEl.getAttribute("type") || "video/mp4";
              const sourceNode = document.createElement("source");
              sourceNode.setAttribute("src", src);
              sourceNode.setAttribute("type", type);
              video.appendChild(sourceNode);
            }
            card.appendChild(video);
          } else {
            const img = document.createElement("img");
            img.className = "media-img pinned-media";
            img.src = media.getAttribute("src") || "";
            img.alt = media.getAttribute("alt") || "";
            card.appendChild(img);
          }
        }

        const link = document.createElement("a");
        link.className = "subtle-link";
        link.href = `#${targetId}`;
        link.textContent = "Jump to full post";
        card.appendChild(link);
      });
    };

    const buildPostSummaries = () => {
      feedPosts.forEach((post) => {
        const firstParagraph = post.querySelector("p");
        if (!firstParagraph) return;

        const summary = document.createElement("p");
        summary.className = "post-summary";
        summary.textContent = getFirstSentence(firstParagraph.textContent.trim());
        post.insertBefore(summary, firstParagraph);

        const mediaSummary = document.createElement("div");
        mediaSummary.className = "post-media-summary";
        const mediaItems = Array.from(post.querySelectorAll("img, video"));
        mediaItems.forEach((item) => {
          if (item.closest(".post-media-summary")) return;
          const clone = item.cloneNode(true);
          clone.classList.add("media-thumb");
          if (clone.tagName.toLowerCase() === "video") {
            clone.removeAttribute("controls");
            clone.muted = true;
            clone.loop = true;
            clone.playsInline = true;
            clone.autoplay = true;
            clone.preload = "metadata";
          }
          mediaSummary.appendChild(clone);
        });
        if (mediaSummary.children.length) {
          post.insertBefore(mediaSummary, firstParagraph);
        }

        const body = document.createElement("div");
        body.className = "post-body";
        post.insertBefore(body, firstParagraph);

        let current = body.nextSibling;
        while (current) {
          const next = current.nextSibling;
          body.appendChild(current);
          current = next;
        }

        const toggle = document.createElement("button");
        toggle.type = "button";
        toggle.className = "post-toggle";
        toggle.textContent = "Read More";
        toggle.setAttribute("aria-expanded", "false");
        toggle.addEventListener("click", () => {
          const expanded = post.classList.toggle("expanded");
          toggle.textContent = expanded ? "Read Less" : "Read More";
          toggle.setAttribute("aria-expanded", expanded ? "true" : "false");
        });
        post.appendChild(toggle);
      });
    };

    const modal = document.getElementById("media-modal");
    const modalImage = modal?.querySelector(".media-modal__img");
    const closeModal = () => {
      if (!modal || !modalImage) return;
      modal.classList.remove("is-open");
      modal.setAttribute("aria-hidden", "true");
      modalImage.src = "";
    };
    const openModal = (src, alt) => {
      if (!modal || !modalImage) return;
      modalImage.src = src;
      modalImage.alt = alt || "";
      modal.classList.add("is-open");
      modal.setAttribute("aria-hidden", "false");
    };

    buildPostSummaries();
    populatePinnedPosts();

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      if (target.closest("[data-modal-close]")) {
        closeModal();
        return;
      }
      const image = target.closest("img.media-img, img.media-thumb");
      if (image instanceof HTMLImageElement) {
        openModal(image.src, image.alt);
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") closeModal();
    });
  </script>
</body>
</html>
